package main

const MaxLights = 128
// Lights restore detail more aggressively near sources but never exceed base.
const LightScale = 2
// Strong darkening for barely visible ambient at 100% night.
const DarkScale  = 0.25

var (
    LightCount int
    DarkCount int
    LightPosX [MaxLights]float
    LightPosY [MaxLights]float
    LightRadius [MaxLights]float
    LightR [MaxLights]float
    LightG [MaxLights]float
    LightB [MaxLights]float
    DarkPosX [MaxLights]float
    DarkPosY [MaxLights]float
    DarkRadius [MaxLights]float
    DarkAlpha [MaxLights]float
)

func Fragment(pos vec4, texCoord vec2, color vec4) vec4 {
    // Base sprite color
    base := imageSrc0At(texCoord)

    // Accumulate darkening multiplicatively (subtractive only)
    dim := vec3(1.0, 1.0, 1.0)
    for i := 0; i < MaxLights; i++ {
        if i < DarkCount {
            dx := pos.x - DarkPosX[i]
            dy := pos.y - DarkPosY[i]
            dist := sqrt(dx*dx + dy*dy)
            nd := dist / DarkRadius[i]
            f := 1.0 / (1.0 + nd*nd)
            d := clamp(DarkScale*DarkAlpha[i]*f, 0.0, 1.0)
            dim *= vec3(1.0 - d)
        }
    }
    col := vec4(base.rgb*dim, base.a)

    // Accumulate light contributions using a per-channel maximum instead of
    // summation/union so many small lights don't wash out night globally.
    // This keeps only the strongest nearby light dominant at each pixel.
    lacc := vec3(0.0, 0.0, 0.0)
    for i := 0; i < MaxLights; i++ {
        if i < LightCount {
            dx := pos.x - LightPosX[i]
            dy := pos.y - LightPosY[i]
            dist := sqrt(dx*dx + dy*dy)
            nd := dist / LightRadius[i]
            f := 1.0 / (1.0 + nd*nd)
            // Sharper falloff so distant lights don't affect ambient much
            f = f * f
            lr := clamp(LightScale*LightR[i]*f, 0.0, 1.0)
            lg := clamp(LightScale*LightG[i]*f, 0.0, 1.0)
            lb := clamp(LightScale*LightB[i]*f, 0.0, 1.0)
            // Per-channel max: only the strongest light wins at a pixel
            lacc.r = max(lacc.r, lr)
            lacc.g = max(lacc.g, lg)
            lacc.b = max(lacc.b, lb)
        }
    }
    // Blend back toward the original base color using lacc
    col.r = col.r*(1.0 - lacc.r) + base.r*lacc.r
    col.g = col.g*(1.0 - lacc.g) + base.g*lacc.g
    col.b = col.b*(1.0 - lacc.b) + base.b*lacc.b

    col.r = clamp(col.r, 0.0, 1.0)
    col.g = clamp(col.g, 0.0, 1.0)
    col.b = clamp(col.b, 0.0, 1.0)
    return col
}
