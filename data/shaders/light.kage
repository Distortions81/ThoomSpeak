package main

const MaxLights = 128
// Lights restore detail more aggressively near sources but never exceed base.
const LightScale = 4
// Strong darkening for barely visible ambient at 100% night.
const DarkScale  = 0.25

var (
    LightCount int
    DarkCount int
    LightPosX [MaxLights]float
    LightPosY [MaxLights]float
    LightRadius [MaxLights]float
    LightR [MaxLights]float
    LightG [MaxLights]float
    LightB [MaxLights]float
    DarkPosX [MaxLights]float
    DarkPosY [MaxLights]float
    DarkRadius [MaxLights]float
    DarkAlpha [MaxLights]float
)

func Fragment(pos vec4, texCoord vec2, color vec4) vec4 {
    // Base sprite color
    base := imageSrc0At(texCoord)

    // Accumulate darkening multiplicatively (subtractive only)
    dim := vec3(1.0, 1.0, 1.0)
    for i := 0; i < MaxLights; i++ {
        if i < DarkCount {
            dx := pos.x - DarkPosX[i]
            dy := pos.y - DarkPosY[i]
            dist := sqrt(dx*dx + dy*dy)
            nd := dist / DarkRadius[i]
            f := 1.0 / (1.0 + nd*nd)
            d := clamp(DarkScale*DarkAlpha[i]*f, 0.0, 1.0)
            dim *= vec3(1.0 - d)
        }
    }
    col := vec4(base.rgb*dim, base.a)

    // Accumulate light contributions additively so lights mix smoothly.
    // Apply a simple Reinhard-like saturation to avoid wash-out.
    lacc := vec3(0.0, 0.0, 0.0)
    for i := 0; i < MaxLights; i++ {
        if i < LightCount {
            dx := pos.x - LightPosX[i]
            dy := pos.y - LightPosY[i]
            dist := sqrt(dx*dx + dy*dy)
            nd := dist / LightRadius[i]
            f := 1.0 / (1.0 + nd*nd)
            // Sharper falloff so distant lights don't affect ambient much
            f = f * f
            contrib := vec3(
                clamp(LightScale*LightR[i]*f, 0.0, 1.0),
                clamp(LightScale*LightG[i]*f, 0.0, 1.0),
                clamp(LightScale*LightB[i]*f, 0.0, 1.0),
            )
            lacc += contrib
        }
    }
    // Soft saturate to [0,1) so overlapping lights brighten without abrupt borders
    lacc = lacc / (1.0 + lacc)
    // Blend back toward the original base color using lacc per channel
    col.r = col.r*(1.0 - lacc.r) + base.r*lacc.r
    col.g = col.g*(1.0 - lacc.g) + base.g*lacc.g
    col.b = col.b*(1.0 - lacc.b) + base.b*lacc.b

    col.r = clamp(col.r, 0.0, 1.0)
    col.g = clamp(col.g, 0.0, 1.0)
    col.b = clamp(col.b, 0.0, 1.0)
    return col
}
